<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LoL Draft</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: #121212;
            color: white;
            margin: 0;
            padding: 20px;
        }
        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            border-radius: 6px;
            color: white;
            font-weight: bold;
            z-index: 1000;
        }
        .notification.success { background: #2ecc71; }
        .notification.error { background: #e74c3c; }
        #notification { display: none; }

        #phase-indicator {
            text-align: center;
            font-size: 1.4em;
            margin: 20px 0;
            color: #4fc3f7;
        }

        .draft-line {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
        }

        .champion-slot {
            width: 60px;
            height: 60px;
            border: 2px solid #444;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #1e1e1e;
        }

        .champion-slot.empty {
            border-style: dashed;
            color: #aaa;
            font-size: 0.7em;
            text-align: center;
        }

        .champion-slot img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 4px;
        }

        .team-blue { order: -1; }
        .team-red { order: 1; }

        #champion-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 10px;
            max-width: 1200px;
            margin: 30px auto;
        }

        .champion-card {
            width: 60px;
            height: 60px;
            cursor: pointer;
            border-radius: 6px;
            overflow: hidden;
            background: #2a2a2a;
            transition: opacity 0.2s;
        }

        .champion-card:hover {
            transform: scale(1.1);
            z-index: 10;
            position: relative;
        }

        .champion-card.unavailable {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .champion-card img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .turn-indicator {
            text-align: center;
            margin-top: 20px;
            font-size: 1.1em;
        }

        .your-turn {
            color: #2ecc71;
            font-weight: bold;
        }

        .not-your-turn {
            color: #e74c3c;
        }
    </style>
</head>
<body>

<div id="notification"></div>
<div id="phase-indicator">Loading draft...</div>

<!-- Blue Team -->
<div class="draft-line team-blue">
    <div id="blue-bans"></div>
</div>
<div class="draft-line team-blue">
    <div id="blue-picks"></div>
</div>

<!-- Champion Grid -->
<div id="champion-grid"></div>

<!-- Red Team -->
<div class="draft-line team-red">
    <div id="red-picks"></div>
</div>
<div class="draft-line team-red">
    <div id="red-bans"></div>
</div>

<div class="turn-indicator" id="turn-indicator">Checking turn...</div>

<script>
// === DOM Elements ===
const blueBansEl = document.getElementById('blue-bans');
const redBansEl = document.getElementById('red-bans');
const bluePicksEl = document.getElementById('blue-picks');
const redPicksEl = document.getElementById('red-picks');
const phaseIndicator = document.getElementById('phase-indicator');
const championGrid = document.getElementById('champion-grid');
const notificationEl = document.getElementById('notification');
const turnIndicator = document.getElementById('turn-indicator');

// === State ===
let currentRoomId = null;

// === Utility Functions ===
function showNotification(message, isError = false) {
    notificationEl.textContent = message;
    notificationEl.className = `notification ${isError ? 'error' : 'success'}`;
    notificationEl.style.display = 'block';
    setTimeout(() => {
        notificationEl.style.display = 'none';
    }, 3000);
}

function createEmptySlot(label = '') {
    const div = document.createElement('div');
    div.className = 'champion-slot empty';
    div.textContent = label;
    return div;
}

function createChampionSlot(name, iconUrl) {
    const div = document.createElement('div');
    div.className = 'champion-slot';

    if (iconUrl) {
        const img = document.createElement('img');
        img.src = iconUrl;
        img.alt = name;
        img.loading = 'lazy';
        div.appendChild(img);
    } else {
        div.textContent = name;
    }
    return div;
}

// === Champion Data Loading ===
async function loadChampions() {
    try {
        const response = await fetch('/static/champions.json');
        if (!response.ok) throw new Error('Champions not loaded');
        const data = await response.json();
        return Object.values(data);
    } catch (error) {
        console.warn('Using fallback champions');
        return [
            { name: 'Ahri', icon: '/static/icons/Ahri.png' },
            { name: 'Yasuo', icon: '/static/icons/Yasuo.png' },
            { name: 'Lux', icon: '/static/icons/Lux.png' },
            { name: 'Zed', icon: '/static/icons/Zed.png' },
            { name: 'Jinx', icon: '/static/icons/Jinx.png' },
        ];
    }
}

function renderChampionGrid(champions) {
    championGrid.innerHTML = '';
    champions.forEach(champ => {
        const card = document.createElement('div');
        card.className = 'champion-card';
        card.dataset.name = champ.name;

        if (champ.icon) {
            const img = document.createElement('img');
            img.src = champ.icon;
            img.alt = champ.name;
            img.loading = 'lazy';
            card.appendChild(img);
        } else {
            card.textContent = champ.name;
        }

        card.addEventListener('click', () => handleChampionClick(champ.name));
        championGrid.appendChild(card);
    });
}

function markUnavailableChampions(unavailableNames) {
    const allCards = championGrid.querySelectorAll('.champion-card');
    allCards.forEach(card => {
        const name = card.dataset.name;
        if (unavailableNames.has(name)) {
            card.classList.add('unavailable');
        } else {
            card.classList.remove('unavailable');
        }
    });
}

// === Core Draft Logic ===
async function loadRoomState() {
    const pathParts = window.location.pathname.split('/');
    const roomIndex = pathParts.indexOf('room');
    currentRoomId = roomIndex !== -1 ? pathParts[roomIndex + 1] : null;

    if (!currentRoomId) {
        showNotification('Room ID not found in URL', true);
        return null;
    }

    try {
        const res = await fetch(`/api/room/${currentRoomId}/status/`);
        if (!res.ok) throw new Error('Room not found');
        return await res.json();
    } catch (err) {
        console.error('Failed to load room:', err);
        showNotification('Failed to load room', true);
        return null;
    }
}

function renderBansAndPicks(actions) {
    const blueBans = actions.filter(a => a.side === 'blue' && a.action_type === 'ban');
    const redBans = actions.filter(a => a.side === 'red' && a.action_type === 'ban');
    const bluePicks = actions.filter(a => a.side === 'blue' && a.action_type === 'pick');
    const redPicks = actions.filter(a => a.side === 'red' && a.action_type === 'pick');

    // Clear
    blueBansEl.innerHTML = '';
    redBansEl.innerHTML = '';
    bluePicksEl.innerHTML = '';
    redPicksEl.innerHTML = '';

    // Render bans (5 slots)
    for (let i = 0; i < 5; i++) {
        blueBansEl.appendChild(i < blueBans.length
            ? createChampionSlot(blueBans[i].champion_name)
            : createEmptySlot('Ban')
        );
        redBansEl.appendChild(i < redBans.length
            ? createChampionSlot(redBans[i].champion_name)
            : createEmptySlot('Ban')
        );
    }

    // Render picks (5 slots)
    for (let i = 0; i < 5; i++) {
        bluePicksEl.appendChild(i < bluePicks.length
            ? createChampionSlot(bluePicks[i].champion_name)
            : createEmptySlot('Pick')
        );
        redPicksEl.appendChild(i < redPicks.length
            ? createChampionSlot(redPicks[i].champion_name)
            : createEmptySlot('Pick')
        );
    }

    // Disable unavailable
    const unavailable = new Set([...blueBans, ...redBans, ...bluePicks, ...redPicks].map(a => a.champion_name));
    markUnavailableChampions(unavailable);
}

async function handleChampionClick(champName) {
    const state = await loadRoomState();
    if (!state) return;

    const userUUID = localStorage.getItem('user_uid');
    if (!userUUID) {
        showNotification('User not logged in', true);
        return;
    }

    const isBlue = state.blue_captain === userUUID;
    const isRed = state.red_captain === userUUID;
    const isMyTurn = (isBlue && state.current_turn === 'blue') || (isRed && state.current_turn === 'red');

    if (!isMyTurn) {
        showNotification('Not your turn!', true);
        return;
    }

    const totalBans = state.actions.filter(a => a.action_type === 'ban').length;
    const actionType = totalBans < 10 ? 'ban' : 'pick';

    try {
        const response = await fetch(`/api/room/${currentRoomId}/draft/`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ user_uuid: userUUID, champion: champName, action: actionType })
        });

        if (!response.ok) {
            const err = await response.json().catch(() => ({}));
            showNotification(err.error || 'Action failed', true);
            return;
        }

        showNotification(`Champion ${actionType}ed!`);
        await refreshUI(); // reload state
    } catch (e) {
        console.error(e);
        showNotification('Network error', true);
    }
}

async function refreshUI() {
    const state = await loadRoomState();
    if (!state) return;

    // Update phase
    const totalBans = state.actions.filter(a => a.action_type === 'ban').length;
    const totalPicks = state.actions.filter(a => a.action_type === 'pick').length;
    const isBlueTurn = state.current_turn === 'blue';

    let phaseText = 'Draft Complete!';
    if (totalBans < 10) {
        phaseText = `Ban Phase: ${isBlueTurn ? 'Blue' : 'Red'} Team (${totalBans + 1}/10)`;
    } else if (totalPicks < 10) {
        phaseText = `Pick Phase: ${isBlueTurn ? 'Blue' : 'Red'} Team (${totalPicks + 1}/10)`;
    }
    phaseIndicator.textContent = phaseText;

    // Update turn indicator
    const userUUID = localStorage.getItem('user_uid');
    const isMyTurn = (state.blue_captain === userUUID && state.current_turn === 'blue') ||
                     (state.red_captain === userUUID && state.current_turn === 'red');
    turnIndicator.textContent = isMyTurn ? 'Your turn!' : 'Opponent\'s turn';
    turnIndicator.className = `turn-indicator ${isMyTurn ? 'your-turn' : 'not-your-turn'}`;

    // Render actions
    renderBansAndPicks(state.actions);
}

// === Initialization ===
(async () => {
    if (!championGrid) return;

    const champions = await loadChampions();
    renderChampionGrid(champions);

    // Initial load
    await refreshUI();

    // Optional: auto-refresh every 3 seconds for real-time sync
    // setInterval(refreshUI, 3000);
})();
</script>

</body>
</html>